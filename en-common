If the broker holding the leader for the partition fails to serve the data due to any failure, one of its respective ISR replicas will takeover the leadership. 
Afterward, if the previous leader returns back, it tries to acquire its leadership again.

If the value of key=NULL, it means that the data is sent without a key. Thus, it will be distributed in a round-robin manner (i.e., distributed to each partition).

If the value of the key!=NULL, it means the key is attached with the data, and thus all messages will always be delivered to the same partition.

If you don't have ``sudo`` permissions or want to install the AWS CLI v2 only for the current user, run the `install` script with the `-b` and `-i` options


https://viblo.asia/p/load-balancing-voi-nginx-bWrZnVxnZxw


What is the difference between SonarQube and Checkmarx CxSAST?
What is the common thing between these two?
In which situations are SonarQube and Checkmarx preferred?

Hi all. I'm new to using DefectDojo, I recently installed it, but unfortunately I don't know how to import reports from checkmarx, I searched for tutorials or something and got nothing.
Anyone who has the steps will be great and healful

I'm creating and installing an SSL certificate via command line for the first time and have a question.

The DefectDojo-Java-Client has been moved to https://github.com/SDA-SE/defectdojo-client. In case you are looking for a java library, take a look at https://github.com/secureCodeBox/defectdojo-client-java.

1. Go to URL in your browser:
  - firefox - click on HTTPS certificate chain (the lock icon right next to URL address). Click "more info" > "security" > "show certificate" > "details" > "export..". Pickup the name and choose file type example.cer
  - chrome - click on site icon left to address in address bar, select "Certificate" -> "Details" -> "Export" and save in format "Der-encoded binary, single certificate".
2. Now you have file with keystore and you have to add it to your JVM. Determine location of cacerts files, eg. C:\Program Files (x86)\Java\jre1.6.0_22\lib\security\cacerts. 
3. Next import the example.cer file into cacerts in command line (may need administrator command prompt):

keytool -import -alias example -keystore  "C:\Program Files (x86)\Java\jre1.6.0_22\lib\security\cacerts" -file example.cer
You will be asked for password which default is changeit

Restart your JVM/PC.

Minh yeu nhau di 
Ke danh cap mat trang
Co hen voi thanh xuan



Stock market: thị trường chứng khoán
Share: cổ phiếu
Stock: cổ phần
Securities: chứng khoán
Stock exchange: sàn giao dịch chứng khoán
Index:  chỉ số
Point: điểm
Share certificate: chứng chỉ cổ phiếu
Interest: tiền lãi
Interest rate: lãi suất
Dividend:  cổ tức
Yield: lợi tức, lợi suất đầu tư (%)
Leverage: đòn bẩy
Margin: ký quỹ, giao dịch ký quỹ
Invest: đầu tư
Investment: sự đầu tư, khoản đầu tư
Inverstor: nhà đầu tư
Shareholder: cổ đông
Stockholder: cổ đông
Speculator: nhà đầu cơ chứng khoán
Stockbroker: người môi giới chứng khoán, người mua/bán cổ phần, cổ phiếu cho khách hàng
Bull market: (thị trường bò tót) thị trường giá đi lên
Bear market: (thị trường gấu) thị trường giá đi xuống
Initial Public Offering (IPO): chào bán cổ phiếu ra công chúng lần đầu tiên
Portfolio: danh mục đầu tư
Annual report: báo cáo thường niên
Annual general meeting of shareholders: Cuộc họp đại hội đồng cổ đông thường niên
Capital: vốn
Market capitalization (market cap): giá trị vốn hóa thị trường


K8s Horizontal Pod Autoscaler | HPA Manifest File Explained | Pod Requests Limits | HPA Demo    link: https://www.youtube.com/watch?v=3BnrXapY7zo

CPU là tên viết tắt của (Central Processing Unit) hiểu cơ bản nhất là một cơ quan đầu não trong máy tính có vai trò chính là phân tích và xử lý dữ liệu được truyền tải đến thông qua các tập lệnh.
GPU (Graphic Proccessing Unit): Là bộ vi xử lý chuyên phân tích những tác vụ liên quan tới đồ họa và video, những khối dữ liệu hình ảnh. Khác với CPU, GPU chuyên thực hiện nhiệm vụ xử lý những tác vụ hình ảnh.
Trình quản lý bộ nhớ của Linux giới hạn dung lượng của mỗi không gian swap là 2GB, tuy nhiên bạn có thể sử dụng đồng thời đến 8 swap spaces , tất cả là 16BG.

https://github.com/kubernetes-sigs/metrics-server/issues/146

https://www.linuxsysadmins.com/service-unavailable-kubernetes-metrics/

Here is an XML example to configure Logback using active Spring profiles.

<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/base.xml" />
    <springProfile name="dev,staging">
        <logger name="guru.springframework.controllers" level="DEBUG" additivity="false">
            <appender-ref ref="CONSOLE" />
        </logger>>
    </springProfile>
    <springProfile name="production">
        <logger name="guru.springframework.controllers" level="WARN" additivity="false">
            <appender-ref ref="FILE" />
        </logger>
    </springProfile>
 </configuration>
In the configuration code above, for the dev and staging profiles, we configured the 
guru.springframework.controllers logger to log DEBUG and higher level messages to console. 
For the production profile, we configured the same logger to log WARN and higher level messages to a file.
To pass a profile to the application, run the application with the -Dspring.profiles.active= JVM argument.

Another approach that could handle multiple profiles is to create a separate properties file for each environment.
  application-prod.properties
    logging.config=classpath:logback-prod.xml
  application-dev.properties
    logging.config=classpath:logback-dev.xml
  application-local.properties
    logging.config=classpath:logback-local.xml
BE AWARE
If you aren't careful you could end up logging somewhere unexpected
  -Dspring.profiles.active=local,dev //will use logback-dev.xml
  -Dspring.profiles.active=dev,local //will use logback-local.xml
Phải đúng tên logback hoặc logback* nó mới nhận, k đúng tên thì k nhận gì cả, và phải để trong thư mục resource để nó quét file đó.
ví dụ: logback-test.xml thì để trong src/test/resources, còn logback.xml thì để trong src/main/resources

trong logback lấy đc tên pod để làm file, có thể nó sử dụng spring cloud: spring-cloud-starter-sleuth dependency và spring-cloud-dependencies dependencyManagement
MDC.get("traceId") nó sẽ get X-B3-TraceId từ logback của log4j, có thể chỉ sử dụng spring cloud mới có X-B3-TraceId

mvn test -Dtests=ApplicationTests -Dlogging.config=classpath:logback-test.xml

Swap là khái niệm bộ nhớ ảo được sử dụng trên hệ điều hành Linux. Khi VPS/Server hoạt động, nếu hết RAM hệ thống sẽ tự động sử dụng một phần ổ cứng để làm bộ nhớ cho các ứng dụng hoạt động.
Nếu hệ thống thiếu RAM, Linux sẽ chuyển cache vào SWAP để dành toàn bộ RAM cho các process đang thực thi.
Vậy muốn biết hệ thống của bạn có đang bị thiếu RAM, hãy nhìn vào chỉ số SWAP. Nếu SWAP cao nghĩa là máy đang thiếu RAM
Câu lệnh Free là lệnh đơn giản và dễ sử dụng nhất để kiểm tra việc sử dụng bộ nhớ trên linux:
	free -m  
Lệnh vmstat với tùy chọn s, đưa ra số liệu thống kê sử dụng bộ nhớ giống như lệnh Proc:
	vmstat -s
  Xem thêm các tham số khác, thì dùng --help
Kiểm tra số core CPU trên máy:
	cat /proc/cpuinfo | grep -c 'core id' | uniq | wc -l
Kiểm tra tổng số thread, của mỗi core:
	cat /proc/cpuinfo | grep processor | uniq | wc -l
  Ví dụ: có 4 core, mỗi core là 1 thread
Lệnh top và htop:
	lệnh top để Kiểm tra hiệu năng CPU: 
		Dòng đầu tiên cho biết:
			+ thời gian hiện tại là 19:58
			+ Server đã được bật 2 ngày
			+ Số user đang login : 1
			+ Load trung bình của server trong 5/10/15 phút lần lượt là 1,38, 1,15, 0,87 phần này khá quan trọng và mình sẽ nói cụ thể hơn bên dưới
		Dòng số 2 cho biết có số lượng tiến trình đang hoạt động
		Dòng số 3: cho biết tình trạng sử dụng CPU. 16.5 us, 8,3 sy nghĩa là user dùng 16.5% và system dùng 8,3%
		Tiếp theo là các thông tin về RAM và SWAP mình sẽ nói cụ thể hơn ở phần RAM bên dưới
	Giải thích Load AVG CPU: Load avg có thể hiểu là TỔNG số lượng process trung bình trong hàng chờ của CPU. Load avg thường được biểu diễn dưới dạng 3 con số, là trung bình trong 5-10-15 phút. 
		Ví dụ ở đây mình có 4 CPU có nghĩa và load avg trong 5 phút là 1.38. Có nghĩa là Load avg / 1 CPU là: 1.38/4 =0.345
	    Con số này càng cao thì số lượng process phải chờ CPU xử lí càng nhiều. Phải hiểu rằng, tại 1 thời điểm, 1 cpu chỉ có thể thực thi 1 process. Những process khác sẽ phải chờ đến khi CPU rảnh mới có thể được thực hiện. Cần phân biệt con số này với % sử dụng CPU.
			+ % sử dụng CPU cho biết 1 process sử dụng CPU nhiều hay ít
			+ Load avg thế hiện số process phải chờ CPU nhiều hay ít
		Nắm được 2 con số này sẽ giúp ta đánh giá được hiệu quả hoạt động của CPU và có những giải pháp thích hợp. Ví dụ như với một máy chủ lưu trữ image dùng chung, hoặc 1 máy chủ LB, không cần xử lí nhiều Logic, chùng ta không cần CPU quá mạnh nhưng sẽ cần nhiều luồng để xử lí nhiều request đồng thời
		Đối với việc theo dõi Load avg của CPU, các quản trị viên thường lấy mốc 0.7 /1CPU làm mốc. Nếu vượt ngưỡng này, cần phải theo dõi và có những giải pháp thích hợp (tăng cpu, tăng luồng,..).
Kiểm tra thông tin CPU:
	cat /proc/cpuinfo


I am using logback with slf4j in my Maven Java project. Currently logback config file (logback.xml) is in src -> main -> resources folder. And it is working fine.
My issue is, I need to give my client the ability to configure logging as he prefers. For that logback.xml should be outside the jar when I build it. But as xml is inside src folder it is inside the jar and no one can change it after build.
How to achieve this?

2 tech stack phổ biến nhất hiện nay cho việc log là ELK (Elasticsearch Logstash Kibana) và EFK (Elasticsearch FluentD Kibana).
FluentD cũng là một công cụ dùng để thu thập log giống như Filebeat và Logstash. FluentD bao gồm các tính năng như theo dõi log, thu thập, phân tích và chuyển đổi log thành dạng thích hợp để lưu vào Elasticsearch. FluentD được phát triển bởi Cloud Native Computing Foundation (CNCF), đây là tổ chức phát triển và bảo trì kubernetes.

Todo:
  k8s
  aws
